{"ast":null,"code":"const hash = require('string-hash');\n\nconst color = require('tinycolor2');\n\nexport const gradient = (uid, type = 'diagonal', opacity = 1) => {\n  if (uid) {\n    const n = hash(uid);\n    let c1 = color({\n      h: n % 360,\n      s: 0.95,\n      l: 0.5,\n      a: opacity\n    });\n    let c1_ = c1.toRgbString();\n    let c2 = c1.triad()[1];\n    c2.setAlpha(opacity);\n    c2 = c2.toRgbString();\n\n    switch (type) {\n      case 'diagonal':\n        return `linear-gradient(to top right, ${c1_}, ${c2})`;\n\n      case 'radial':\n        return `radial-gradient(circle, ${c1_}, ${c2})`;\n\n      case 'horizontal':\n        return `linear-gradient(${c1_}, ${c2})`;\n\n      case 'vertical':\n        return `linear-gradient(to right, ${c1_}, ${c2})`;\n\n      default:\n        return `linear-gradient(to top right, ${c1_}, ${c2})`;\n    }\n  }\n\n  throw new TypeError('uid is required');\n};\n\nfunction randomGradient(opacity) {\n  const types = [\"linear-gradient\", \"radial-gradient\"];\n  let type = types[Math.floor(Math.random() * types.length)];\n  const options = [\"to top\", \"to left\", \"to bottom left\"];\n  let option = options[Math.floor(Math.random() * options.length)];\n  let val = [];\n  let min = Math.ceil(50);\n  let max = Math.floor(255);\n\n  for (let i = 0; i <= 6; i++) {\n    val.push(Math.floor(Math.random() * (max - min + 1)) + min);\n  }\n\n  if (type === 'radial-gradient') option = \"circle at center\"; // return type + '(' + option + ', rgba(' + val[0] + ', ' + val[1] + ', ' + val[3] + ', ' + opacity + '), ' +\n  // 'rgba(' + val[4] + ', ' + val[5] + ', ' + val[6] + ', ' + opacity + '))'\n\n  return type + '(' + option + ',' + getRandomColor() + ',' + getRandomColor() + ')';\n}\n\nfunction getRandomColor() {\n  const trans = '1';\n  let color = 'rgba(';\n\n  for (let i = 0; i < 3; i++) {\n    let min = Math.ceil(50);\n    let max = Math.floor(255);\n    color += Math.floor(Math.random() * (max - min + 1)) + min + ',';\n  }\n\n  color += trans + ')';\n  return color;\n}","map":{"version":3,"sources":["/Users/marcin/Desktop/flask-react-blog/frontend/src/services/gradient.js"],"names":["hash","require","color","gradient","uid","type","opacity","n","c1","h","s","l","a","c1_","toRgbString","c2","triad","setAlpha","TypeError","randomGradient","types","Math","floor","random","length","options","option","val","min","ceil","max","i","push","getRandomColor","trans"],"mappings":"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","sourcesContent":["const hash = require('string-hash')\nconst color = require('tinycolor2')\n\nexport const gradient = (uid, type = 'diagonal', opacity = 1) => {\n    if (uid) {\n        const n = hash(uid)\n        let c1 = color({h: n % 360, s: 0.95, l: 0.5, a: opacity})\n        let c1_ = c1.toRgbString()\n        let c2 = c1.triad()[1]\n        c2.setAlpha(opacity)\n        c2 = c2.toRgbString()\n\n        switch (type) {\n            case 'diagonal':\n                return `linear-gradient(to top right, ${c1_}, ${c2})`\n\n            case 'radial':\n                return `radial-gradient(circle, ${c1_}, ${c2})`\n\n            case 'horizontal':\n                return `linear-gradient(${c1_}, ${c2})`\n\n            case 'vertical':\n                return `linear-gradient(to right, ${c1_}, ${c2})`\n\n            default:\n                return `linear-gradient(to top right, ${c1_}, ${c2})`\n        }\n    }\n\n    throw new TypeError('uid is required')\n}\n\nfunction randomGradient(opacity) {\n    const types = [\"linear-gradient\", \"radial-gradient\"];\n    let type = types[Math.floor(Math.random() * types.length)];\n    const options = [\"to top\", \"to left\", \"to bottom left\"]\n    let option = options[Math.floor(Math.random() * options.length)];\n    let val = [];\n    let min = Math.ceil(50);\n    let max = Math.floor(255);\n    for (let i = 0; i <= 6; i++) {\n        val.push(Math.floor(Math.random() * (max - min + 1)) + min);\n    }\n    if (type === 'radial-gradient') option = \"circle at center\"\n\n    // return type + '(' + option + ', rgba(' + val[0] + ', ' + val[1] + ', ' + val[3] + ', ' + opacity + '), ' +\n    // 'rgba(' + val[4] + ', ' + val[5] + ', ' + val[6] + ', ' + opacity + '))'\n\n    return type + '(' + option + ',' + getRandomColor() + ',' + getRandomColor() + ')'\n}\n\nfunction getRandomColor() {\n    const trans = '1';\n    let color = 'rgba(';\n    for (let i = 0; i < 3; i++) {\n        let min = Math.ceil(50);\n        let max = Math.floor(255);\n        color += Math.floor(Math.random() * (max - min + 1)) + min + ',';\n    }\n    color += trans + ')';\n    return color;\n}"]},"metadata":{},"sourceType":"module"}